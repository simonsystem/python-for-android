diff --git a/Lib/platform.py b/Lib/platform.py
index 9096696..66a6455 100755
--- a/Lib/platform.py
+++ b/Lib/platform.py
@@ -382,6 +382,64 @@ def dist(distname='', version='', id='',
                                supported_dists=supported_dists,
                                full_distribution_name=0)
 
+_android_environment_vars = (
+    'ANDROID_ROOT', 'ANDROID_ASSETS', 'ANDROID_STORAGE', 'ANDROID_DATA',
+    'ANDROID_PROPERTY_WORKSPACE', 'ANDROID_BOOTLOGO')
+_android_version_property = 'ro.build.version.release'
+_android_buildstr_property = 'ro.build.version.full'
+
+def android_version(version='', buildstr=''):
+    """ Attempt to get the Android version number and build string.
+
+        The function checks for the getprop binary to retrieve build info,
+        and falls back to manually reading /system/build.prop if available.
+
+        Returns a (version, buildstr) tuple which defaults to the args given
+        as parameters.
+    """
+    if not any(os.getenv(e) for e in _android_environment_vars):
+        # Probably not on Android...
+        return version, buildstr
+
+    version_obtained = False
+    buildstr_obtained = False
+
+    # Try the 'official' API tool first, since /system/build.prop might
+    # not be the only source for properties.
+    if os.access('/system/bin/getprop', os.X_OK):
+        try:
+            output = subprocess.check_output(['/system/bin/getprop',
+                                              _android_version_property])
+            version = output.decode('ascii').strip()
+            version_obtained = True
+        except (subprocess.CalledProcessError, UnicodeDecodeError):
+            pass
+
+        try:
+            output = subprocess.check_output(['/system/bin/getprop',
+                                              _android_buildstr_property])
+            buildstr = output.decode('ascii').strip()
+            buildstr_obtained = True
+        except (subprocess.CalledProcessError, UnicodeDecodeError):
+            pass
+    done = version_obtained and buildstr_obtained
+
+    # Fall back to parsing /system/build.prop manually.
+    if not done and os.path.isfile('/system/build.prop'):
+        for line in open('/system/build.prop'):
+            if '=' not in line:
+                continue
+            key, val = line.split('=')
+            key = key.strip()
+
+            if not version_obtained and key == _android_version_property:
+                version = val.strip()
+            elif not buildstr_obtained and key == _android_buildstr_property:
+                buildstr = val.strip()
+
+    return version, buildstr
+
+
 def popen(cmd, mode='r', bufsize=-1):
 
     """ Portable popen() interface.
diff --git a/Lib/subprocess.py b/Lib/subprocess.py
index b6c4374..51dec9c 100644
--- a/Lib/subprocess.py
+++ b/Lib/subprocess.py
@@ -1429,9 +1429,18 @@ class Popen(object):
                 args = list(args)
 
             if shell:
-                args = ["/bin/sh", "-c"] + args
                 if executable:
-                    args[0] = executable
+                    main = executable
+                elif os.path.isfile('/bin/sh'):
+                    main = '/bin/sh'
+                else:
+                    import platform
+                    if platform.android_version()[0]:
+                        main = '/system/bin/sh'
+                    else:
+                        raise RuntimeError('Could not find system shell')
+
+                args = [main, "-c"] + args
 
             if executable is None:
                 executable = args[0]
diff --git a/Lib/test/test_subprocess.py b/Lib/test/test_subprocess.py
index 9c0229a..d711647 100644
--- a/Lib/test/test_subprocess.py
+++ b/Lib/test/test_subprocess.py
@@ -18,6 +18,7 @@ import select
 import shutil
 import gc
 import textwrap
+import platform
 
 try:
     import threading
@@ -1530,8 +1531,11 @@ class POSIXProcessTestCase(BaseTestCase):
         fd, fname = mkstemp()
         # reopen in text mode
         with open(fd, "w", errors="surrogateescape") as fobj:
-            fobj.write("#!/bin/sh\n")
-            fobj.write("exec '%s' -c 'import sys; sys.exit(47)'\n" %
+            if platform.android_version()[0]:
+                fobj.write('#!/system/bin/sh\n')
+            else:
+                fobj.write("#!/bin/sh\n")
+           fobj.write("exec '%s' -c 'import sys; sys.exit(47)'\n" %
                        sys.executable)
         os.chmod(fname, 0o700)
         p = subprocess.Popen(fname)
@@ -1575,7 +1579,10 @@ class POSIXProcessTestCase(BaseTestCase):
         fd, fname = mkstemp()
         # reopen in text mode
         with open(fd, "w", errors="surrogateescape") as fobj:
-            fobj.write("#!/bin/sh\n")
+            if platform.android_version()[0]:
+                fobj.write('#!/system/bin/sh\n')
+            else:
+                fobj.write("#!/bin/sh\n")
             fobj.write("exec '%s' -c 'import sys; sys.exit(47)'\n" %
                        sys.executable)
         os.chmod(fname, 0o700)
diff --git a/Makefile.pre.in b/Makefile.pre.in
index ce2c0aa..cc401eb 100644
--- a/Makefile.pre.in
+++ b/Makefile.pre.in
@@ -580,7 +580,7 @@ sharedmods: $(BUILDPYTHON) pybuilddir.txt
 	    *\ -s*|s*) quiet="-q";; \
 	    *) quiet="";; \
 	esac; \
-	$(RUNSHARED) CC='$(CC)' LDSHARED='$(BLDSHARED)' OPT='$(OPT)' \
+	$(RUNSHARED) CC='$(CC)' LDSHARED='$(BLDSHARED) -lpython$(LDVERSION)' OPT='$(OPT)' \
 		_TCLTK_INCLUDES='$(TCLTK_INCLUDES)' _TCLTK_LIBS='$(TCLTK_LIBS)' \
 		$(PYTHON_FOR_BUILD) $(srcdir)/setup.py $$quiet build
 
@@ -597,11 +597,9 @@ $(LIBRARY): $(LIBRARY_OBJS)
 	$(RANLIB) $@
 
 libpython$(LDVERSION).so: $(LIBRARY_OBJS)
+	$(BLDSHARED) -Wl,-h$(INSTSONAME) -o $(INSTSONAME) $(LIBRARY_OBJS) $(MODLIBS) $(SHLIBS) $(LIBC) $(LIBM) $(LDLAST); \
 	if test $(INSTSONAME) != $(LDLIBRARY); then \
-		$(BLDSHARED) -Wl,-h$(INSTSONAME) -o $(INSTSONAME) $(LIBRARY_OBJS) $(MODLIBS) $(SHLIBS) $(LIBC) $(LIBM) $(LDLAST); \
 		$(LN) -f $(INSTSONAME) $@; \
-	else \
-		$(BLDSHARED) -o $@ $(LIBRARY_OBJS) $(MODLIBS) $(SHLIBS) $(LIBC) $(LIBM) $(LDLAST); \
 	fi
 
 libpython3.so:	libpython$(LDVERSION).so
diff --git a/Modules/Setup.dist b/Modules/Setup.dist
index 06ba6ad..3c5115c 100644
--- a/Modules/Setup.dist
+++ b/Modules/Setup.dist
@@ -121,7 +121,7 @@ _stat _stat.c			# stat.h interface
 time timemodule.c	# -lm # time operations and variables
 
 # access to ISO C locale support
-_locale _localemodule.c  # -lintl
+#_locale _localemodule.c  # -lintl
 
 # Standard I/O baseline
 _io -I$(srcdir)/Modules/_io _io/_iomodule.c _io/iobase.c _io/fileio.c _io/bytesio.c _io/bufferedio.c _io/textio.c _io/stringio.c
diff --git a/Modules/_decimal/libmpdec/io.c b/Modules/_decimal/libmpdec/io.c
index a45a429..e87101d 100644
--- a/Modules/_decimal/libmpdec/io.c
+++ b/Modules/_decimal/libmpdec/io.c
@@ -868,10 +868,16 @@ mpd_parse_fmt_str(mpd_spec_t *spec, const char *fmt, int caps)
         }
         spec->type = *cp++;
         spec->type = (spec->type == 'N') ? 'G' : 'g';
+#ifdef __ANDROID__
+        spec->dot = ".";
+        spec->sep = ",";
+        spec->grouping = "\3";
+#else
         lc = localeconv();
         spec->dot = lc->decimal_point;
         spec->sep = lc->thousands_sep;
         spec->grouping = lc->grouping;
+#endif
         if (mpd_validate_lconv(spec) < 0) {
             return 0; /* GCOV_NOT_REACHED */
         }
diff --git a/Modules/_localemodule.c b/Modules/_localemodule.c
index b1d6add..2c6ec0e 100644
--- a/Modules/_localemodule.c
+++ b/Modules/_localemodule.c
@@ -38,6 +38,13 @@ This software comes with no warranty. Use at your own risk.
 #include <windows.h>
 #endif
 
+#if __ANDROID__
+/* Android's locale support is pretty much unusable, it's better to have the
+   higher-level module fall back to C locale emulation. */
+#error "Android's locale support is too incomplete to create a usable module."
+#endif
+
+
 PyDoc_STRVAR(locale__doc__, "Support for POSIX locales.");
 
 static PyObject *Error;
@@ -141,6 +148,11 @@ PyLocale_localeconv(PyObject* self)
     if (!result)
         return NULL;
 
+#ifdef __ANDROID__
+    /* Don't even try on Android's broken locale.h. */
+    goto failed;
+#else
+
     /* if LC_NUMERIC is different in the C library, use saved value */
     l = localeconv();
 
@@ -196,6 +208,8 @@ PyLocale_localeconv(PyObject* self)
     RESULT_INT(n_sign_posn);
     return result;
 
+#endif // __ANDROID__
+
   failed:
     Py_XDECREF(result);
     return NULL;
diff --git a/Modules/main.c b/Modules/main.c
index 2a9ea28..e32f305 100644
--- a/Modules/main.c
+++ b/Modules/main.c
@@ -549,7 +549,7 @@ Py_Main(int argc, wchar_t **argv)
         oldloc = _PyMem_RawStrdup(setlocale(LC_ALL, NULL));
         setlocale(LC_ALL, "");
         for (p = strtok(buf, ","); p != NULL; p = strtok(NULL, ",")) {
-#ifdef __APPLE__
+#if defined(__APPLE__) || defined(__ANDROID__)
             /* Use utf-8 on Mac OS X */
             unicode = PyUnicode_FromString(p);
 #else
diff --git a/Modules/posixmodule.c b/Modules/posixmodule.c
index ec8c526..08e8021 100644
--- a/Modules/posixmodule.c
+++ b/Modules/posixmodule.c
@@ -387,6 +387,11 @@ PyAPI_FUNC(void) _Py_time_t_to_FILE_TIME(time_t, int, FILETIME *);
 PyAPI_FUNC(void) _Py_attribute_data_to_stat(BY_HANDLE_FILE_INFORMATION *,
                                             ULONG, struct _Py_stat_struct *);
 #endif
+  
+/* Android doesn't expose AT_EACCESS - manually define it. */
+#if !defined(AT_EACCESS) && defined(__ANDROID__)
+#define AT_EACCESS     0x200
+#endif
 
 #ifdef MS_WINDOWS
 static int
diff --git a/Modules/pwdmodule.c b/Modules/pwdmodule.c
index 281c30b..28b93c2 100644
--- a/Modules/pwdmodule.c
+++ b/Modules/pwdmodule.c
@@ -78,7 +78,11 @@ mkpwent(struct passwd *p)
     SETS(setIndex++, p->pw_passwd);
     PyStructSequence_SET_ITEM(v, setIndex++, _PyLong_FromUid(p->pw_uid));
     PyStructSequence_SET_ITEM(v, setIndex++, _PyLong_FromGid(p->pw_gid));
+#if !defined(__ANDROID__)
     SETS(setIndex++, p->pw_gecos);
+#else
+    SETS(setIndex++, "");
+#endif
     SETS(setIndex++, p->pw_dir);
     SETS(setIndex++, p->pw_shell);
 
diff --git a/Modules/socketmodule.c b/Modules/socketmodule.c
index ee24907..3718f70 100644
--- a/Modules/socketmodule.c
+++ b/Modules/socketmodule.c
@@ -148,7 +148,7 @@ if_indextoname(index) -- return the corresponding interface name\n\
    On the other hand, not all Linux versions agree, so there the settings
    computed by the configure script are needed! */
 
-#ifndef linux
+#if !defined(linux) || __ANDROID__
 # undef HAVE_GETHOSTBYNAME_R_3_ARG
 # undef HAVE_GETHOSTBYNAME_R_5_ARG
 # undef HAVE_GETHOSTBYNAME_R_6_ARG
@@ -167,7 +167,7 @@ if_indextoname(index) -- return the corresponding interface name\n\
 #  define HAVE_GETHOSTBYNAME_R_3_ARG
 # elif defined(__sun) || defined(__sgi)
 #  define HAVE_GETHOSTBYNAME_R_5_ARG
-# elif defined(linux)
+# elif defined(linux) && !__ANDROID__
 /* Rely on the configure script */
 # else
 #  undef HAVE_GETHOSTBYNAME_R
diff --git a/Objects/unicodeobject.c b/Objects/unicodeobject.c
index 9223c99..1f8f625 100644
--- a/Objects/unicodeobject.c
+++ b/Objects/unicodeobject.c
@@ -3163,12 +3163,20 @@ static int
 locale_error_handler(const char *errors, int *surrogateescape)
 {
     if (errors == NULL) {
+#ifdef __ANDROID__
+        *surrogateescape = 1;
+#else
         *surrogateescape = 0;
+#endif
         return 0;
     }
 
     if (strcmp(errors, "strict") == 0) {
+#ifdef __ANDROID__
+        *surrogateescape = 1;
+#else
         *surrogateescape = 0;
+#endif
         return 0;
     }
     if (strcmp(errors, "surrogateescape") == 0) {
@@ -3297,7 +3305,7 @@ PyUnicode_EncodeFSDefault(PyObject *unicode)
 {
 #ifdef HAVE_MBCS
     return PyUnicode_EncodeCodePage(CP_ACP, unicode, NULL);
-#elif defined(__APPLE__)
+#elif defined(__APPLE__) || defined(__ANDROID__)
     return _PyUnicode_AsUTF8String(unicode, "surrogateescape");
 #else
     PyInterpreterState *interp = PyThreadState_GET()->interp;
@@ -3581,7 +3589,7 @@ PyUnicode_DecodeFSDefaultAndSize(const char *s, Py_ssize_t size)
 {
 #ifdef HAVE_MBCS
     return PyUnicode_DecodeMBCS(s, size, NULL);
-#elif defined(__APPLE__)
+#elif defined(__APPLE__) || defined(__ANDROID__)
     return PyUnicode_DecodeUTF8Stateful(s, size, "surrogateescape", NULL);
 #else
     PyInterpreterState *interp = PyThreadState_GET()->interp;
@@ -4769,7 +4777,7 @@ onError:
     return NULL;
 }
 
-#ifdef __APPLE__
+#if defined(__APPLE__) || defined(__ANDROID__)
 
 /* Simplified UTF-8 decoder using surrogateescape error handler,
    used to decode the command line arguments on Mac OS X.
diff --git a/Python/bltinmodule.c b/Python/bltinmodule.c
index 2f22209..ba42d84 100644
--- a/Python/bltinmodule.c
+++ b/Python/bltinmodule.c
@@ -24,7 +24,7 @@
 #ifdef HAVE_MBCS
 const char *Py_FileSystemDefaultEncoding = "mbcs";
 int Py_HasFileSystemDefaultEncoding = 1;
-#elif defined(__APPLE__)
+#elif defined(__APPLE__) || defined(__ANDROID__)
 const char *Py_FileSystemDefaultEncoding = "utf-8";
 int Py_HasFileSystemDefaultEncoding = 1;
 #else
diff --git a/Python/fileutils.c b/Python/fileutils.c
index bccd321..48ae1a5 100644
--- a/Python/fileutils.c
+++ b/Python/fileutils.c
@@ -20,7 +20,7 @@ extern int winerror_to_errno(int);
 #include <fcntl.h>
 #endif /* HAVE_FCNTL_H */
 
-#ifdef __APPLE__
+#if defined(__APPLE__) || defined(__ANDROID__)
 extern wchar_t* _Py_DecodeUTF8_surrogateescape(const char *s, Py_ssize_t size);
 #endif
 
@@ -70,7 +70,7 @@ _Py_device_encoding(int fd)
     Py_RETURN_NONE;
 }
 
-#if !defined(__APPLE__) && !defined(MS_WINDOWS)
+#if !defined(__APPLE__) && !defined(__ANDROID__) && !defined(MS_WINDOWS)
 extern int _Py_normalize_encoding(const char *, char *, size_t);
 
 /* Workaround FreeBSD and OpenIndiana locale encoding issue with the C locale.
@@ -220,7 +220,7 @@ encode_ascii_surrogateescape(const wchar_t *text, size_t *error_pos)
 }
 #endif   /* !defined(__APPLE__) && !defined(MS_WINDOWS) */
 
-#if !defined(__APPLE__) && (!defined(MS_WINDOWS) || !defined(HAVE_MBRTOWC))
+#if !defined(__APPLE__) && !defined(__ANDROID__) && (!defined(MS_WINDOWS) || !defined(HAVE_MBRTOWC))
 static wchar_t*
 decode_ascii_surrogateescape(const char *arg, size_t *size)
 {
@@ -272,7 +272,7 @@ decode_ascii_surrogateescape(const char *arg, size_t *size)
 wchar_t*
 Py_DecodeLocale(const char* arg, size_t *size)
 {
-#ifdef __APPLE__
+#if defined(__APPLE__) || defined(__ANDROID__)
     wchar_t *wstr;
     wstr = _Py_DecodeUTF8_surrogateescape(arg, strlen(arg));
     if (size != NULL) {
@@ -423,7 +423,7 @@ oom:
 char*
 Py_EncodeLocale(const wchar_t *text, size_t *error_pos)
 {
-#ifdef __APPLE__
+#if defined(__APPLE__) || defined(__ANDROID__)
     Py_ssize_t len;
     PyObject *unicode, *bytes = NULL;
     char *cpath;
diff --git a/Python/formatter_unicode.c b/Python/formatter_unicode.c
index 056bb76..c9d761e 100644
--- a/Python/formatter_unicode.c
+++ b/Python/formatter_unicode.c
@@ -667,6 +667,7 @@ get_locale_info(int type, LocaleInfo *locale_info)
 {
     switch (type) {
     case LT_CURRENT_LOCALE: {
+#ifndef __ANDROID__
         struct lconv *locale_data = localeconv();
         locale_info->decimal_point = PyUnicode_DecodeLocale(
                                          locale_data->decimal_point,
@@ -682,6 +683,7 @@ get_locale_info(int type, LocaleInfo *locale_info)
         }
         locale_info->grouping = locale_data->grouping;
         break;
+#endif // __ANDROID__
     }
     case LT_DEFAULT_LOCALE:
         locale_info->decimal_point = PyUnicode_FromOrdinal('.');
diff --git a/Python/pylifecycle.c b/Python/pylifecycle.c
index a17adf7..0843158 100644
--- a/Python/pylifecycle.c
+++ b/Python/pylifecycle.c
@@ -224,6 +224,8 @@ get_locale_encoding(void)
         return NULL;
     }
     return get_codec_name(codeset);
+#elif __ANDROID__
+    return get_codec_name("UTF-8");
 #else
     PyErr_SetNone(PyExc_NotImplementedError);
     return NULL;
diff --git a/Python/pystrtod.c b/Python/pystrtod.c
index 209c908..6bd792a 100644
--- a/Python/pystrtod.c
+++ b/Python/pystrtod.c
@@ -177,8 +177,12 @@ _PyOS_ascii_strtod(const char *nptr, char **endptr)
 
     fail_pos = NULL;
 
+#ifdef __ANDROID__
+	decimal_point = ".";
+#else
     locale_data = localeconv();
     decimal_point = locale_data->decimal_point;
+#endif
     decimal_point_len = strlen(decimal_point);
 
     assert(decimal_point_len != 0);
@@ -378,8 +382,12 @@ PyOS_string_to_double(const char *s,
 Py_LOCAL_INLINE(void)
 change_decimal_from_locale_to_dot(char* buffer)
 {
+#ifdef __ANDROID__
+		const char *decimal_point = ".";
+#else
     struct lconv *locale_data = localeconv();
     const char *decimal_point = locale_data->decimal_point;
+#endif
 
     if (decimal_point[0] != '.' || decimal_point[1] != 0) {
         size_t decimal_point_len = strlen(decimal_point);
diff --git a/configure b/configure
index e823a08..dc7c760 100755
--- a/configure
+++ b/configure
@@ -5065,6 +5065,35 @@ fi
 
 MULTIARCH=$($CC --print-multiarch 2>/dev/null)
 
+# Test if we're running on Android.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if target is Android-based" >&5
+$as_echo_n "checking if target is Android-based... " >&6; }
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+#if __ANDROID__
+yes
+#endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "yes" >/dev/null 2>&1; then :
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+    with_android=yes
+
+else
+
+    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+    with_android=no
+
+
+fi
+rm -f conftest*
+
+
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for the platform triplet based on compiler characteristics" >&5
 $as_echo_n "checking for the platform triplet based on compiler characteristics... " >&6; }
@@ -5791,7 +5820,13 @@ $as_echo "#define Py_ENABLE_SHARED 1" >>confdefs.h
 	  LDLIBRARY='libpython$(LDVERSION).so'
 	  BLDLIBRARY='-L. -lpython$(LDVERSION)'
 	  RUNSHARED=LD_LIBRARY_PATH=`pwd`${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}
-	  INSTSONAME="$LDLIBRARY".$SOVERSION
+      if test "$with_android" != yes
+         then
+             INSTSONAME="$LDLIBRARY".$SOVERSION
+      else
+          INSTSONAME="LDLIBRARY"
+      fi
+
 	  if test "$with_pydebug" != yes
           then
 	      PY3LIBRARY=libpython3.so
diff --git a/configure.ac b/configure.ac
index 56a73df..3245d87 100644
--- a/configure.ac
+++ b/configure.ac
@@ -726,6 +726,22 @@ fi
 MULTIARCH=$($CC --print-multiarch 2>/dev/null)
 AC_SUBST(MULTIARCH)
 
+# Test if we're running on Android.
+AC_MSG_CHECKING(if target is Android-based)
+AC_EGREP_CPP(yes,
+[
+#if __ANDROID__
+yes
+#endif
+], [
+    AC_MSG_RESULT(yes)
+    with_android=yes
+   ], [
+    AC_MSG_RESULT(no)
+    with_android=no
+   ]
+)
+
 AC_MSG_CHECKING([for the platform triplet based on compiler characteristics])
 cat >> conftest.c <<EOF
 #undef bfin
@@ -1094,7 +1110,14 @@ if test $enable_shared = "yes"; then
 	  LDLIBRARY='libpython$(LDVERSION).so'
 	  BLDLIBRARY='-L. -lpython$(LDVERSION)'
 	  RUNSHARED=LD_LIBRARY_PATH=`pwd`${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}
-	  INSTSONAME="$LDLIBRARY".$SOVERSION
+
+	  if test "$with_android" != yes
+	  then
+		INSTSONAME="$LDLIBRARY".$SOVERSION
+	  else
+		INSTSONAME="$LDLIBRARY"
+	  fi
+
 	  if test "$with_pydebug" != yes
           then
 	      PY3LIBRARY=libpython3.so
